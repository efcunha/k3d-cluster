#!/bin/sh

# Configuração variaveis de ambiente
CLUSTER_DOMAIN=devops.com
API_PORT=6443
CLUSTER_NAME=k3d-rancher
READ_VALUE=
SERVERS=1
AGENTS=1
TRAEFIK_V2=Yes
INSTALL_INGRESS=Yes
INSTALL_RANCHER=Yes
INSTALL_DASHBOARD=No
INSTALL_PROMETHEUS=No

# bold text 
bold=$(tput bold)
normal=$(tput sgr0)
yes_no="(${bold}Y${normal}es/${bold}N${normal}o)"


# $1 text to show - $2 default value
read_value ()
{
    read -p "${1} [${bold}${2}${normal}]: " READ_VALUE
    if [ "${READ_VALUE}" = "" ]
    then
        READ_VALUE=$2
    fi
}

# Verifica se existe docker, k3d e kubectl
checkDependencies ()
{
    # Check Docker
    if ! type docker > /dev/null; then
        echo "Docker could not be found. Installing it ..."
        curl -L -o ./install-docker.sh "https://get.docker.com"
        chmod +x ./install-docker.sh
        ./install-docker.sh
        sudo usermod -aG docker $USER
        #exit
    fi

    # Check K3D
    if ! type k3d > /dev/null; then
        echo "K3D could not be found. Installing it ..."
        curl -s https://raw.githubusercontent.com/rancher/k3d/main/install.sh | bash
        # Instale o autocompletar k3d para o bash
        echo "source <(k3d completion bash)" >> ~/.bashrc
        #exit
    fi

    # Check Kubectl
    if ! type kubectl > /dev/null; then
        echo "Kubectl could not be found. Installing it ..."
        curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x ./kubectl
        sudo mv ./kubectl /usr/local/bin/kubectl
        kubectl version --client
        #exit
    fi

    # Check Helm
    if ! type helm > /dev/null; then
        echo "Helm could not be found. Installing it ..."
        curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3
        chmod +x ./get_helm.sh
        ./get_helm.sh
        
        # Add default repos
        helm repo add stable https://charts.helm.sh/stable
        # Add kubernetes-dashboard repository
        helm repo add kubernetes-dashboard https://kubernetes.github.io/dashboard/
        # Add bitnami helm repos
        helm repo add bitnami https://charts.bitnami.com/bitnami
        # Add Prometheus helm repos
        helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
        # Add Rancher helm repos
        helm repo add rancher-latest https://releases.rancher.com/server-charts/latest
        # Add jetstack helm repos
	      helm repo add jetstack https://charts.jetstack.io
        # Update helm
        helm repo update
        #exit
    fi
}

header()
{
    echo "\n\n${bold}${1}${normal}\n-------------------------------------"
}

footer()
{
    echo "-------------------------------------"
}

configValues ()
{
  read_value "Nome Cluster" "${CLUSTER_NAME}"
  CLUSTER_NAME=${READ_VALUE}
  read_value "Cluster Domain" "${CLUSTER_DOMAIN}"
  CLUSTER_DOMAIN=${READ_VALUE}
  read_value "Porta API" "${API_PORT}"
  API_PORT=${READ_VALUE}
  read_value "Servers (Masters)" "${SERVERS}"
  SERVERS=${READ_VALUE}
  read_value "Agents (Workers)" "${AGENTS}"
  AGENTS=${READ_VALUE}
}

installCluster ()
{
  header "Deletando Previous Cluster"
  k3d cluster delete ${CLUSTER_NAME}
  footer

  header "Criando K3D cluster"
  cat <<EOF  > tmp-k3d-${CLUSTER_NAME}.yaml
apiVersion: k3d.io/v1alpha2
kind: Simple
name: ${CLUSTER_NAME}
servers: ${SERVERS} 
agents: ${AGENTS}
kubeAPI:
  hostIP: "0.0.0.0"
  hostPort: "${API_PORT}" # kubernetes api port 6443:6443

image: rancher/k3s:latest

volumes:
  - volume: $(pwd)/k3dvol:/k3dvol # volume in host:container
    nodeFilters:
      - all

ports:
  - port: 0.0.0.0:80:80
    nodeFilters:
      - loadbalancer
  - port: 0.0.0.0:443:443
    nodeFilters:
      - loadbalancer
  - port: 0.0.0.0:8900:30080
    nodeFilters:
      - loadbalancer
  - port: 0.0.0.0:8901:30081
    nodeFilters:
      - loadbalancer
  - port: 0.0.0.0:8902:30082
    nodeFilters:
      - loadbalancer

env:
  - envVar: secret=token
    nodeFilters:
      - all
labels:
  - label: best_cluster=forced_tag
    nodeFilters:
      - server[0]  
      - loadbalancer

options:
  k3d:
    wait: true
    timeout: "60s" # avoid an start/stop cicle when start fails
    disableLoadbalancer: false
    disableImageVolume: false
  k3s:
    extraServerArgs:
      - --tls-san=127.0.0.1
      - --no-deploy=traefik

    extraAgentArgs: []
  kubeconfig:
    updateDefaultKubeconfig: true # update kubeconfig when cluster starts
    switchCurrentContext: true # change this cluster context when cluster starts
EOF

  k3d cluster create --config tmp-k3d-${CLUSTER_NAME}.yaml

  header "waiting for cluster init ..."
  sleep 5    

  kubectl config use-context k3d-${CLUSTER_NAME}
  kubectl cluster-info
  footer

  header "Provisioning Persistent Volume"
  cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: PersistentVolume
metadata:
  name: k3d-pv
  labels:
    type: local
spec:
  storageClassName: manual
  capacity:
    storage: 50Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/k3dvol"  
EOF
  footer
}

installIngress ()
{
  header "Instaling Ingress"
  sudo apt-get update -y
  sudo apt-get install wget libnss3-tools
  curl -JLO "https://dl.filippo.io/mkcert/latest?for=linux/amd64"
  chmod +x mkcert-v*-linux-amd64
  sudo cp mkcert-v*-linux-amd64 /usr/local/bin/mkcert
  mkcert -install
  mkcert -CAROOT
  # Criar certificados
  mkcert ${CLUSTER_DOMAIN} localhost 127.0.0.1 192.168.1.10 ::1
  mv *-key.pem certs/${CLUSTER_DOMAIN}-key.pem
  mv *.pem certs/${CLUSTER_DOMAIN}.pem
  kubectl create namespace ingress
  kubectl --namespace ingress create secret tls nginx-server-certs --key certs/${CLUSTER_DOMAIN}-key.pem --cert certs/${CLUSTER_DOMAIN}.pem

  cat <<EOF | helm install --namespace ingress -f - ingress bitnami/nginx-ingress-controller
extraArgs:
  default-ssl-certificate: "ingress/nginx-server-certs"
EOF
  footer
  sleep 5
  header "LoadBalancer info:"
  kubectl -n ingress get svc | egrep -e NAME -e LoadBalancer
  sleep 20
  echo "acesso ao Nginx https://127.0.0.1 ou https://nginx.xxxx.com"
  footer
}

installRancher ()
{
  
  kubectl apply --validate=false -f https://github.com/cert-manager/cert-manager/releases/download/v1.8.2/cert-manager.crds.yaml
  sleep 5
  kubectl create namespace cert-manager
  sleep 5
  helm install \
    cert-manager jetstack/cert-manager \
    --namespace cert-manager \
    --version v1.8.2
  sleep 20
  kubectl create namespace cattle-system
  sleep 5

  kubectl -n cattle-system create secret tls tls-rancher-ingress --cert=certs/${CLUSTER_DOMAIN}.pem --key=certs/${CLUSTER_DOMAIN}-key.pem
  sleep 5

  helm install rancher rancher-latest/rancher \
   --namespace cattle-system \
   --set hostname=rancher.${CLUSTER_DOMAIN} \
   --set ingress.enabled=false \
   --set tls=external \
   --set replicas=1

  cat <<EOF | kubectl apply -f -
  apiVersion: v1
  kind: Service
  metadata:
    labels:
      app: rancher
    name: ranchernp
    namespace: cattle-system
  spec:
    ports:
    - name: http
      nodePort: 30080
      port: 80
      protocol: TCP
      targetPort: 80
    - name: https-internal
      nodePort: 30081
      port: 443
      protocol: TCP
      targetPort: 443
    selector:
      app: rancher
    type: NodePort
EOF
  footer
  sleep 5
  kubectl -n cattle-system rollout status deploy/rancher
  sleep 5
  kubectl -n cattle-system get deploy rancher
  echo "acesso ao Rancher https://127.0.0.1:8901 ou https://rancher.xxxx.com:8901"
  footer
}

installDashboard ()
{
  header "Instaling Dashboard"

  kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml

  kubectl create serviceaccount dashboard-admin-sa

  kubectl create clusterrolebinding dashboard-admin-sa --clusterrole=cluster-admin --serviceaccount=default:dashboard-admin-sa
  

  header "Keep this Token to acces dashboard"

  kubectl describe secret $(kubectl get secrets | grep dashboard-admin-sa | awk '{ print $1 }')
  header "Dashboard Access:"
  echo "kubectl proxy"
  echo "http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/login"
  footer
}

installPrometheus ()
{
  header "Instaling Prometheus & Grafana"

  helm install --namespace monitoring --create-namespace prometheus  \
  --set server.global.scrape_interval=30s prometheus-community/prometheus

  helm install --namespace monitoring --create-namespace grafana stable/grafana \
  --set sidecar.datasources.enabled=true --set sidecar.dashboards.enabled=true \
  --set sidecar.datasources.label=grafana_datasource \
  --set sidecar.dashboards.label=grafana_dashboard

cat <<EOF | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: monitoring
  namespace: monitoring
  annotations:
    ingress.kubernetes.io/ssl-redirect: "true"
spec:
  rules:
    - host: grafana.${CLUSTER_DOMAIN}
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: grafana
                port:
                  number: 80
    - host: prometheus.${CLUSTER_DOMAIN}
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: prometheus-server
                port:
                  number: 80
EOF

  header "Grafana and Prometheus Access:"
  echo "${bold}Prometheus${normal}:"
  echo "url: https://prometheus.${CLUSTER_DOMAIN}"
  footer
  echo "${bold}Grafana${normal}:"
  echo "url: https://grafana.${CLUSTER_DOMAIN}"
  echo "username: admin"
  echo "password: $(kubectl get secret --namespace monitoring grafana -o jsonpath="{.data.admin-password}" | base64 --decode ; echo)"
  echo "\nuse 'kubectl get secret --namespace monitoring grafana -o jsonpath="{.data.admin-password}" | base64 --decode ; echo' to get password"
  footer
}

installKubeapps ()
{
  header "Instaling Kubeapps"
  cat <<EOF | helm install --namespace kubeapps --create-namespace -f - kubeapps bitnami/kubeapps
ingress:
  enabled: true
  hostname: kubeapps.${CLUSTER_DOMAIN}
  tls: true
EOF
  #helm install --namespace kubeapps --create-namespace kubeapps bitnami/kubeapps
  kubectl create serviceaccount kubeapps-operator
  kubectl create clusterrolebinding kubeapps-operator --clusterrole=cluster-admin --serviceaccount=default:kubeapps-operator

  echo "url: https://kubeapps.${CLUSTER_DOMAIN}"
  echo "Token: \n$(  kubectl get secret $(kubectl get serviceaccount kubeapps-operator -o jsonpath='{range .secrets[*]}{.name}{"\n"}{end}' | grep kubeapps-operator-token) -o jsonpath='{.data.token}' -o go-template='{{.data.token | base64decode}}' && echo)"
  footer
}

isSelected()
{
  if [ "${1}" = "Yes" ] || [ "${1}" = "yes" ] || [ "${1}" = "Y" ]  || [ "${1}" = "y" ];
  then
    echo 1
  else
    echo 0
  fi
}

installAddons ()
{
  read_value "Install Ingress? ${yes_no}" "${INSTALL_INGRESS}"
  if [ $(isSelected ${READ_VALUE}) = 1 ];
  then
      installIngress
  fi

  read_value "Install Rancher? ${yes_no}" "${INSTALL_RANCHER}"
  if [ $(isSelected ${READ_VALUE}) = 1 ];
  then
      installRancher
  fi

  read_value "Install Dashbard? ${yes_no}" "${INSTALL_DASHBOARD}"
  if [ $(isSelected ${READ_VALUE}) = 1 ];
  then
      installDashboard
  fi

  read_value "Install Prometheus? ${yes_no}" "${INSTALL_PROMETHEUS}"
  if [ $(isSelected ${READ_VALUE}) = 1 ];
  then
      installPrometheus
  fi
}

checkDependencies 

#Retrieve config values 
configValues

# Todo Calico

installCluster

installAddons

